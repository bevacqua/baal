#!/bin/bash

set -e

: "${NODE_ENV:="staging"}"

# configurable variables
TLD="baal.com"
NAME="baal-$NODE_ENV"

# conventions, do not change
ELB_NAME="elb-$NAME"
ASG_NAME="asg-$NAME"
SG_NAME="standard-$NAME"
LC_NAME="lc-$NAME-initial"
KEYFILE="deploy/keys/$NODE_ENV"
HOST_NAME=$NODE_ENV"."

if [ "$HOST_NAME" == "production." ]
then
  HOST_NAME=""
fi

rm -rf deploy/log
mkdir deploy/log

echo "setup: querying hosted zone..."
aws route53 list-hosted-zones-by-name \
  --dns-name $TLD > deploy/log/route53-hosted-zone.log

JQUERY=$(echo "if .HostedZones[0].Name == \"$TLD.\" then .HostedZones[0].Id else \"FAIL\" end")
HOSTED_ZONE=$(jq -r "$JQUERY" < deploy/log/route53-hosted-zone.log)

if [ "$HOSTED_ZONE" == "FAIL" ]
then
  echo "setup: couldn't find hosted zone. please register a route53 hosted zone for $TLD"
  exit 1
fi

echo "setup: creating vpc..."
aws ec2 create-vpc \
  --cidr-block 10.0.0.0/16 > deploy/log/ec2-create-vpc.log

VPC_ID=$(cat deploy/log/ec2-create-vpc.log | jq -r .Vpc.VpcId)

echo "setup: configuring dns for vpc..."
aws ec2 modify-vpc-attribute \
  --vpc-id $VPC_ID \
  --enable-dns-support > deploy/log/ec2-vpc-dns-support.log

aws ec2 modify-vpc-attribute \
  --vpc-id $VPC_ID \
  --enable-dns-hostnames > deploy/log/ec2-vpc-dns-hostnames.log

echo "setup: creating security group for vpc..."
aws ec2 create-security-group \
  --group-name $SG_NAME \
  --vpc-id $VPC_ID \
  --description "Autogenerated security group for $HOST_NAME$TLD" >  deploy/log/ec2-vpc-sg-create.log

SG_ID=$(jq -r .GroupId < deploy/log/ec2-vpc-sg-create.log)

echo "setup: tagging security group..."
aws ec2 create-tags \
  --resources $SG_ID \
  --tags Key=Name,Value=standard-$NAME Key=Role,Value=web > deploy/log/ec2-tag-sg.log

echo "setup: opening up http on security group..."
aws ec2 authorize-security-group-ingress \
  --group-id $SG_ID \
  --protocol tcp \
  --port 80 \
  --cidr 0.0.0.0/0

echo "setup: opening up https on security group..."
aws ec2 authorize-security-group-ingress \
  --group-id $SG_ID \
  --protocol tcp \
  --port 443 \
  --cidr 0.0.0.0/0

# todo: remove this step. instead, grant ssh to current IP temporarily for ssh commands
echo "setup: opening up ssh on security group..."
aws ec2 authorize-security-group-ingress \
  --group-id $SG_ID \
  --protocol tcp \
  --port 22 \
  --cidr 0.0.0.0/0

echo "setup: creating subnet..."
aws ec2 create-subnet \
  --cidr-block 10.0.0.0/16 \
  --vpc-id $VPC_ID > deploy/log/ec2-create-subnet.log

echo "setup: creating internet gateway..."
aws ec2 create-internet-gateway > deploy/log/ec2-create-internet-gateway.log

SUBNET_ID=$(jq -r .Subnet.SubnetId < deploy/log/ec2-create-subnet.log)
IGW_ID=$(jq -r .InternetGateway.InternetGatewayId < deploy/log/ec2-create-internet-gateway.log)

echo "setup: tagging vpc..."
aws ec2 create-tags \
  --resources $VPC_ID \
  --tags Key=Name,Value=vpc-$NAME Key=Role,Value=web > deploy/log/ec2-tag-vpc.log

echo "setup: tagging subnet..."
aws ec2 create-tags \
  --resources $SUBNET_ID \
  --tags Key=Name,Value=subnet-$NAME Key=Role,Value=web > deploy/log/ec2-tag-subnet.log

echo "setup: tagging internet gateway..."
aws ec2 create-tags \
  --resources $IGW_ID \
  --tags Key=Name,Value=igw-$NAME Key=Role,Value=web > deploy/log/ec2-tag-igw.log

echo "setup: attaching internet gateway to vpc..."
aws ec2 attach-internet-gateway \
  --vpc-id $VPC_ID \
  --internet-gateway-id $IGW_ID > deploy/log/ec2-attach-igw.log

echo "setup: creating custom route table..."
aws ec2 create-route-table \
  --vpc-id $VPC_ID > deploy/log/ec2-create-route-table.log

ROUTE_TABLE_ID=$(jq -r .RouteTable.RouteTableId < deploy/log/ec2-create-route-table.log)

echo "setup: associating route table..."
aws ec2 associate-route-table \
  --route-table-id $ROUTE_TABLE_ID \
  --subnet-id $SUBNET_ID > deploy/log/ec2-associate-route-table.log

echo "setup: adding route to internet gateway..."
aws ec2 create-route \
  --route-table-id $ROUTE_TABLE_ID \
  --gateway-id $IGW_ID \
  --destination-cidr-block 0.0.0.0/0 > deploy/log/ec2-create-igw-route.log

echo "setup: creating $ELB_NAME load balancer..."
aws elb create-load-balancer \
  --load-balancer-name "$ELB_NAME" \
  --security-groups $SG_ID \
  --listeners Protocol=TCP,LoadBalancerPort=80,InstanceProtocol=TCP,InstancePort=80 \
  --subnets $SUBNET_ID > deploy/log/elb-create.log

echo "setup: enabling connection draining on elb..."
aws elb modify-load-balancer-attributes \
  --load-balancer-name "$ELB_NAME" \
  --load-balancer-attributes "{\"ConnectionDraining\":{\"Enabled\":true,\"Timeout\":300}}" > deploy/log/elb-draining.log

echo "setup: configuring health checks on elb..."
aws elb configure-health-check \
  --load-balancer-name "$ELB_NAME" \
  --health-check Target=TCP:80,Interval=30,UnhealthyThreshold=2,HealthyThreshold=2,Timeout=4 > deploy/log/elb-health.log

echo "setup: creating proxy protocol policy on elb..."
aws elb create-load-balancer-policy \
  --load-balancer-name "$ELB_NAME" \
  --policy-name "$ELB_NAME-proxy-protocol" \
  --policy-type-name ProxyProtocolPolicyType \
  --policy-attributes AttributeName=ProxyProtocol,AttributeValue=true > deploy/log/elb-create-pp.log

echo "setup: enabling proxy protocol on elb..."
aws elb set-load-balancer-policies-for-backend-server \
  --load-balancer-name "$ELB_NAME" \
  --policy-names "$ELB_NAME-proxy-protocol" \
  --instance-port 80 > deploy/log/elb-enable-pp.log

echo "setup: describing load balancer to create route53 alias recordset..."
aws elb describe-load-balancers \
  --load-balancer-name "$ELB_NAME" > deploy/log/elb-describe-lb.log

ELB_ZONE_ID=$(jq -r '.LoadBalancerDescriptions[0].CanonicalHostedZoneNameID' < deploy/log/elb-describe-lb.log)
ELB_ZONE_NAME=$(jq -r '.LoadBalancerDescriptions[0].CanonicalHostedZoneName' < deploy/log/elb-describe-lb.log)

echo "setup: creating route53 alias recordset on $HOST_NAME$TLD..."
echo "{
  \"Changes\": [{
    \"Action\": \"UPSERT\",
    \"ResourceRecordSet\": {
      \"Type\": \"A\",
      \"Name\": \"$HOST_NAME$TLD.\",
      \"AliasTarget\": {
        \"HostedZoneId\": \"$ELB_ZONE_ID\",
        \"DNSName\": \"$ELB_ZONE_NAME\",
        \"EvaluateTargetHealth\": true
      }
    }
  }]
}" > deploy/log/route53-record-set-changes.log

aws route53 change-resource-record-sets \
  --hosted-zone-id "$HOSTED_ZONE" \
  --change-batch "file://deploy/log/route53-record-set-changes.log" > deploy/log/route53-change-recordset.log

if [ -f "$KEYFILE" ]
then
  echo "setup: ssh key file already exists on aws."
else
  echo "setup: ssh key file doesn't exist yet. creating..."
  mkdir -p deploy/keys
  ssh-keygen -t rsa -b 4096 -N "" -f "$KEYFILE"
  aws ec2 import-key-pair \
    --key-name "$NAME" \
    --public-key-material "file://$KEYFILE.pub" > deploy/log/ec2-upload-keypair.log
  echo "setup: ssh key file uploaded to aws."
fi

echo "setup: done."
